module.exports = {

"[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable camelcase */ const { format } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const makeError = __turbopack_context__.r("[project]/node_modules/make-error/index.js [app-route] (ecmascript)");
function OPError({ error_description, error, error_uri, session_state, state, scope }, response) {
    OPError.super.call(this, !error_description ? error : `${error} (${error_description})`);
    Object.assign(this, {
        error
    }, error_description && {
        error_description
    }, error_uri && {
        error_uri
    }, state && {
        state
    }, scope && {
        scope
    }, session_state && {
        session_state
    });
    if (response) {
        Object.defineProperty(this, 'response', {
            value: response
        });
    }
}
makeError(OPError);
function RPError(...args) {
    if (typeof args[0] === 'string') {
        RPError.super.call(this, format(...args));
    } else {
        const { message, printf, response, ...rest } = args[0];
        if (printf) {
            RPError.super.call(this, format(...printf));
        } else {
            RPError.super.call(this, message);
        }
        Object.assign(this, rest);
        if (response) {
            Object.defineProperty(this, 'response', {
                value: response
            });
        }
    }
}
makeError(RPError);
module.exports = {
    OPError,
    RPError
};
}}),
"[project]/node_modules/openid-client/lib/helpers/base64url.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
let encode;
if (Buffer.isEncoding('base64url')) {
    encode = (input, encoding = 'utf8')=>Buffer.from(input, encoding).toString('base64url');
} else {
    const fromBase64 = (base64)=>base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    encode = (input, encoding = 'utf8')=>fromBase64(Buffer.from(input, encoding).toString('base64'));
}
const decode = (input)=>Buffer.from(input, 'base64');
module.exports.decode = decode;
module.exports.encode = encode;
}}),
"[project]/node_modules/openid-client/lib/helpers/is_plain_object.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = (a)=>!!a && a.constructor === Object;
}}),
"[project]/node_modules/openid-client/lib/helpers/defaults.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-restricted-syntax, no-continue */ const isPlainObject = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/is_plain_object.js [app-route] (ecmascript)");
function defaults(deep, target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === '__proto__' || key === 'constructor') {
                continue;
            }
            if (typeof target[key] === 'undefined' && typeof value !== 'undefined') {
                target[key] = value;
            }
            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {
                defaults(true, target[key], value);
            }
        }
    }
    return target;
}
module.exports = defaults.bind(undefined, false);
module.exports.deep = defaults.bind(undefined, true);
}}),
"[project]/node_modules/openid-client/lib/helpers/assert.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
function assertSigningAlgValuesSupport(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;
    if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa] && !issuer[easavs]) {
        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);
    }
}
function assertIssuerConfiguration(issuer, endpoint) {
    if (!issuer[endpoint]) {
        throw new TypeError(`${endpoint} must be configured on the issuer`);
    }
}
module.exports = {
    assertSigningAlgValuesSupport,
    assertIssuerConfiguration
};
}}),
"[project]/node_modules/openid-client/lib/helpers/pick.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = function pick(object, ...paths) {
    const obj = {};
    for (const path of paths){
        if (object[path]) {
            obj[path] = object[path];
        }
    }
    return obj;
};
}}),
"[project]/node_modules/openid-client/lib/helpers/process_response.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { STATUS_CODES } = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
const { format } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { OPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const REGEXP = /(\w+)=("[^"]*")/g;
const throwAuthenticateErrors = (response)=>{
    const params = {};
    try {
        while(REGEXP.exec(response.headers['www-authenticate']) !== null){
            if (RegExp.$1 && RegExp.$2) {
                params[RegExp.$1] = RegExp.$2.slice(1, -1);
            }
        }
    } catch (err) {}
    if (params.error) {
        throw new OPError(params, response);
    }
};
const isStandardBodyError = (response)=>{
    let result = false;
    try {
        let jsonbody;
        if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {
            jsonbody = JSON.parse(response.body);
        } else {
            jsonbody = response.body;
        }
        result = typeof jsonbody.error === 'string' && jsonbody.error.length;
        if (result) response.body = jsonbody;
    } catch (err) {}
    return result;
};
function processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {
    if (response.statusCode !== statusCode) {
        if (bearer) {
            throwAuthenticateErrors(response);
        }
        if (isStandardBodyError(response)) {
            throw new OPError(response.body, response);
        }
        throw new OPError({
            error: format('expected %i %s, got: %i %s', statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])
        }, response);
    }
    if (body && !response.body) {
        throw new OPError({
            error: format('expected %i %s with body but no body was returned', statusCode, STATUS_CODES[statusCode])
        }, response);
    }
    return response.body;
}
module.exports = processResponse;
}}),
"[project]/node_modules/openid-client/lib/helpers/unix_timestamp.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = ()=>Math.floor(Date.now() / 1000);
}}),
"[project]/node_modules/openid-client/lib/token_set.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const base64url = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/base64url.js [app-route] (ecmascript)");
const now = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/unix_timestamp.js [app-route] (ecmascript)");
class TokenSet {
    /**
   * @name constructor
   * @api public
   */ constructor(values){
        Object.assign(this, values);
    }
    /**
   * @name expires_in=
   * @api public
   */ set expires_in(value) {
        this.expires_at = now() + Number(value);
    }
    /**
   * @name expires_in
   * @api public
   */ get expires_in() {
        return Math.max.apply(null, [
            this.expires_at - now(),
            0
        ]);
    }
    /**
   * @name expired
   * @api public
   */ expired() {
        return this.expires_in === 0;
    }
    /**
   * @name claims
   * @api public
   */ claims() {
        if (!this.id_token) {
            throw new TypeError('id_token not present in TokenSet');
        }
        return JSON.parse(base64url.decode(this.id_token.split('.')[1]));
    }
}
module.exports = TokenSet;
}}),
"[project]/node_modules/openid-client/lib/helpers/generators.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const { createHash, randomBytes } = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const base64url = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/base64url.js [app-route] (ecmascript)");
const random = (bytes = 32)=>base64url.encode(randomBytes(bytes));
module.exports = {
    random,
    state: random,
    nonce: random,
    codeVerifier: random,
    codeChallenge: (codeVerifier)=>base64url.encode(createHash('sha256').update(codeVerifier).digest())
};
}}),
"[project]/node_modules/openid-client/package.json (json)": ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"name\":\"openid-client\",\"version\":\"4.9.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/node-openid-client\",\"repository\":\"panva/node-openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"lib/index.js\",\"types\":\"types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"coverage\":\"nyc mocha test/**/*.test.js\",\"lint\":\"eslint lib test\",\"lint-fix\":\"eslint lib test --fix\",\"test\":\"mocha test/**/*.test.js\"},\"nyc\":{\"reporter\":[\"lcov\",\"text-summary\"]},\"dependencies\":{\"aggregate-error\":\"^3.1.0\",\"got\":\"^11.8.0\",\"jose\":\"^2.0.5\",\"lru-cache\":\"^6.0.0\",\"make-error\":\"^1.3.6\",\"object-hash\":\"^2.0.1\",\"oidc-token-hash\":\"^5.0.1\"},\"devDependencies\":{\"@types/passport\":\"^1.0.4\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.2.0\",\"eslint\":\"^7.12.1\",\"eslint-config-airbnb-base\":\"^14.2.0\",\"eslint-plugin-import\":\"^2.22.1\",\"mocha\":\"^8.2.0\",\"nock\":\"^13.0.2\",\"nyc\":\"^15.1.0\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.0\",\"timekeeper\":\"^2.2.0\"},\"engines\":{\"node\":\"^10.19.0 || >=12.0.0 < 13 || >=13.7.0 < 14 || >= 14.2.0\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Bug Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":true},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}"));}),
"[project]/node_modules/openid-client/lib/helpers/is_absolute_url.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const { strict: assert } = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
module.exports = (target)=>{
    try {
        const { protocol } = new url.URL(target);
        assert(protocol.match(/^(https?:)$/));
        return true;
    } catch (err) {
        throw new TypeError('only valid absolute URLs can be requested');
    }
};
}}),
"[project]/node_modules/openid-client/lib/helpers/consts.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const OIDC_DISCOVERY = '/.well-known/openid-configuration';
const OAUTH2_DISCOVERY = '/.well-known/oauth-authorization-server';
const WEBFINGER = '/.well-known/webfinger';
const REL = 'http://openid.net/specs/connect/1.0/issuer';
const AAD_MULTITENANT_DISCOVERY = [
    `https://login.microsoftonline.com/common${OIDC_DISCOVERY}`,
    `https://login.microsoftonline.com/common/v2.0${OIDC_DISCOVERY}`,
    `https://login.microsoftonline.com/organizations/v2.0${OIDC_DISCOVERY}`,
    `https://login.microsoftonline.com/consumers/v2.0${OIDC_DISCOVERY}`
];
const CLIENT_DEFAULTS = {
    grant_types: [
        'authorization_code'
    ],
    id_token_signed_response_alg: 'RS256',
    authorization_signed_response_alg: 'RS256',
    response_types: [
        'code'
    ],
    token_endpoint_auth_method: 'client_secret_basic'
};
const ISSUER_DEFAULTS = {
    claim_types_supported: [
        'normal'
    ],
    claims_parameter_supported: false,
    grant_types_supported: [
        'authorization_code',
        'implicit'
    ],
    request_parameter_supported: false,
    request_uri_parameter_supported: true,
    require_request_uri_registration: false,
    response_modes_supported: [
        'query',
        'fragment'
    ],
    token_endpoint_auth_methods_supported: [
        'client_secret_basic'
    ]
};
const CALLBACK_PROPERTIES = [
    'access_token',
    'code',
    'error',
    'error_description',
    'error_uri',
    'expires_in',
    'id_token',
    'state',
    'token_type',
    'session_state',
    'response'
];
const JWT_CONTENT = /^application\/jwt/;
const HTTP_OPTIONS = Symbol('openid-client.custom.http-options');
const CLOCK_TOLERANCE = Symbol('openid-client.custom.clock-tolerance');
module.exports = {
    AAD_MULTITENANT_DISCOVERY,
    CALLBACK_PROPERTIES,
    CLIENT_DEFAULTS,
    CLOCK_TOLERANCE,
    HTTP_OPTIONS,
    ISSUER_DEFAULTS,
    JWT_CONTENT,
    OAUTH2_DISCOVERY,
    OIDC_DISCOVERY,
    REL,
    WEBFINGER
};
}}),
"[project]/node_modules/openid-client/lib/helpers/request.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const Got = __turbopack_context__.r("[project]/node_modules/got/dist/source/index.js [app-route] (ecmascript)");
const pkg = __turbopack_context__.r("[project]/node_modules/openid-client/package.json (json)");
const { deep: defaultsDeep } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/defaults.js [app-route] (ecmascript)");
const isAbsoluteUrl = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/is_absolute_url.js [app-route] (ecmascript)");
const { HTTP_OPTIONS } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/consts.js [app-route] (ecmascript)");
let DEFAULT_HTTP_OPTIONS;
let got;
const setDefaults = (options)=>{
    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, options, DEFAULT_HTTP_OPTIONS);
    got = Got.extend(DEFAULT_HTTP_OPTIONS);
};
setDefaults({
    followRedirect: false,
    headers: {
        'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`
    },
    retry: 0,
    timeout: 3500,
    throwHttpErrors: false
});
module.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {
    const { url } = options;
    isAbsoluteUrl(url);
    const optsFn = this[HTTP_OPTIONS];
    let opts = options;
    if (DPoP && 'dpopProof' in this) {
        opts.headers = opts.headers || {};
        opts.headers.DPoP = this.dpopProof({
            htu: url,
            htm: options.method
        }, DPoP, accessToken);
    }
    if (optsFn) {
        opts = optsFn.call(this, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS));
    }
    if (mTLS && (!opts.key || !opts.cert) && (!opts.https || !(opts.https.key && opts.https.certificate || opts.https.pfx))) {
        throw new TypeError('mutual-TLS certificate and key not set');
    }
    return got(opts);
};
module.exports.setDefaults = setDefaults;
}}),
"[project]/node_modules/openid-client/lib/issuer_registry.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const REGISTRY = new Map();
module.exports = REGISTRY;
}}),
"[project]/node_modules/openid-client/lib/helpers/weak_cache.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const privateProps = new WeakMap();
module.exports = (ctx)=>{
    if (!privateProps.has(ctx)) {
        privateProps.set(ctx, new Map([
            [
                'metadata',
                new Map()
            ]
        ]));
    }
    return privateProps.get(ctx);
};
}}),
"[project]/node_modules/openid-client/lib/helpers/merge.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-restricted-syntax, no-param-reassign, no-continue */ const isPlainObject = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/is_plain_object.js [app-route] (ecmascript)");
function merge(target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === '__proto__' || key === 'constructor') {
                continue;
            }
            if (isPlainObject(target[key]) && isPlainObject(value)) {
                target[key] = merge(target[key], value);
            } else if (typeof value !== 'undefined') {
                target[key] = value;
            }
        }
    }
    return target;
}
module.exports = merge;
}}),
"[project]/node_modules/openid-client/lib/helpers/client.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const jose = __turbopack_context__.r("[project]/node_modules/jose/lib/index.js [app-route] (ecmascript)");
const { assertIssuerConfiguration } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/assert.js [app-route] (ecmascript)");
const { random } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/generators.js [app-route] (ecmascript)");
const now = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/unix_timestamp.js [app-route] (ecmascript)");
const request = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/request.js [app-route] (ecmascript)");
const instance = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/weak_cache.js [app-route] (ecmascript)");
const merge = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/merge.js [app-route] (ecmascript)");
const formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, '+');
async function clientAssertion(endpoint, payload) {
    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];
    if (!alg) {
        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);
    }
    if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {
        const key = await this.joseSecret();
        if (!alg) {
            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
            alg = Array.isArray(supported) && supported.find((signAlg)=>key.algorithms('sign').has(signAlg));
        }
        return jose.JWS.sign(payload, key, {
            alg,
            typ: 'JWT'
        });
    }
    const keystore = instance(this).get('keystore');
    if (!keystore) {
        throw new TypeError('no client jwks provided for signing a client assertion with');
    }
    if (!alg) {
        const algs = new Set();
        keystore.all().forEach((key)=>{
            key.algorithms('sign').forEach(Set.prototype.add.bind(algs));
        });
        const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
        alg = Array.isArray(supported) && supported.find((signAlg)=>algs.has(signAlg));
    }
    const key = keystore.get({
        alg,
        use: 'sig'
    });
    if (!key) {
        throw new TypeError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);
    }
    return jose.JWS.sign(payload, key, {
        alg,
        typ: 'JWT',
        kid: key.kid.startsWith('DONOTUSE.') ? undefined : key.kid
    });
}
async function authFor(endpoint, { clientAssertionPayload } = {}) {
    const authMethod = this[`${endpoint}_endpoint_auth_method`];
    switch(authMethod){
        case 'self_signed_tls_client_auth':
        case 'tls_client_auth':
        case 'none':
            return {
                form: {
                    client_id: this.client_id
                }
            };
        case 'client_secret_post':
            if (!this.client_secret) {
                throw new TypeError('client_secret_post client authentication method requires a client_secret');
            }
            return {
                form: {
                    client_id: this.client_id,
                    client_secret: this.client_secret
                }
            };
        case 'private_key_jwt':
        case 'client_secret_jwt':
            {
                const timestamp = now();
                const mTLS = endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;
                const audience = [
                    ...new Set([
                        this.issuer.issuer,
                        this.issuer.token_endpoint,
                        this.issuer[`${endpoint}_endpoint`],
                        mTLS && this.issuer.mtls_endpoint_aliases ? this.issuer.mtls_endpoint_aliases.token_endpoint : undefined
                    ].filter(Boolean))
                ];
                const assertion = await clientAssertion.call(this, endpoint, {
                    iat: timestamp,
                    exp: timestamp + 60,
                    jti: random(),
                    iss: this.client_id,
                    sub: this.client_id,
                    aud: audience,
                    ...clientAssertionPayload
                });
                return {
                    form: {
                        client_id: this.client_id,
                        client_assertion: assertion,
                        client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'
                    }
                };
            }
        default:
            {
                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
                // > The client identifier is encoded using the
                // > "application/x-www-form-urlencoded" encoding algorithm per
                // > Appendix B, and the encoded value is used as the username; the client
                // > password is encoded using the same algorithm and used as the
                // > password.
                if (!this.client_secret) {
                    throw new TypeError('client_secret_basic client authentication method requires a client_secret');
                }
                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;
                const value = Buffer.from(encoded).toString('base64');
                return {
                    headers: {
                        Authorization: `Basic ${value}`
                    }
                };
            }
    }
}
function resolveResponseType() {
    const { length, 0: value } = this.response_types;
    if (length === 1) {
        return value;
    }
    return undefined;
}
function resolveRedirectUri() {
    const { length, 0: value } = this.redirect_uris || [];
    if (length === 1) {
        return value;
    }
    return undefined;
}
async function authenticatedPost(endpoint, opts, { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {}) {
    const auth = await authFor.call(this, endpointAuthMethod, {
        clientAssertionPayload
    });
    const requestOpts = merge(opts, auth);
    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') || endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;
    let targetUrl;
    if (mTLS && this.issuer.mtls_endpoint_aliases) {
        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];
    }
    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];
    if ('form' in requestOpts) {
        for (const [key, value] of Object.entries(requestOpts.form)){
            if (typeof value === 'undefined') {
                delete requestOpts.form[key];
            }
        }
    }
    return request.call(this, {
        ...requestOpts,
        method: 'POST',
        url: targetUrl
    }, {
        mTLS,
        DPoP
    });
}
module.exports = {
    resolveResponseType,
    resolveRedirectUri,
    authFor,
    authenticatedPost
};
}}),
"[project]/node_modules/openid-client/lib/device_flow_handle.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable camelcase */ const { inspect } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { RPError, OPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const instance = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/weak_cache.js [app-route] (ecmascript)");
const now = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/unix_timestamp.js [app-route] (ecmascript)");
const { authenticatedPost } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/client.js [app-route] (ecmascript)");
const processResponse = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/process_response.js [app-route] (ecmascript)");
const TokenSet = __turbopack_context__.r("[project]/node_modules/openid-client/lib/token_set.js [app-route] (ecmascript)");
class DeviceFlowHandle {
    constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }){
        [
            'verification_uri',
            'user_code',
            'device_code'
        ].forEach((prop)=>{
            if (typeof response[prop] !== 'string' || !response[prop]) {
                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);
            }
        });
        if (!Number.isSafeInteger(response.expires_in)) {
            throw new RPError('expected expires_in number to be returned by Device Authorization Response, got %j', response.expires_in);
        }
        instance(this).expires_at = now() + response.expires_in;
        instance(this).client = client;
        instance(this).DPoP = DPoP;
        instance(this).maxAge = maxAge;
        instance(this).exchangeBody = exchangeBody;
        instance(this).clientAssertionPayload = clientAssertionPayload;
        instance(this).response = response;
        instance(this).interval = response.interval * 1000 || 5000;
    }
    abort() {
        instance(this).aborted = true;
    }
    async poll({ signal } = {}) {
        if (signal && signal.aborted || instance(this).aborted) {
            throw new RPError('polling aborted');
        }
        if (this.expired()) {
            throw new RPError('the device code %j has expired and the device authorization session has concluded', this.device_code);
        }
        await new Promise((resolve)=>setTimeout(resolve, instance(this).interval));
        const response = await authenticatedPost.call(instance(this).client, 'token', {
            form: {
                ...instance(this).exchangeBody,
                grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
                device_code: this.device_code
            },
            responseType: 'json'
        }, {
            clientAssertionPayload: instance(this).clientAssertionPayload,
            DPoP: instance(this).DPoP
        });
        let responseBody;
        try {
            responseBody = processResponse(response);
        } catch (err) {
            switch(err instanceof OPError && err.error){
                case 'slow_down':
                    instance(this).interval += 5000;
                case 'authorization_pending':
                    return this.poll({
                        signal
                    });
                default:
                    throw err;
            }
        }
        const tokenset = new TokenSet(responseBody);
        if ('id_token' in tokenset) {
            await instance(this).client.decryptIdToken(tokenset);
            await instance(this).client.validateIdToken(tokenset, undefined, 'token', instance(this).maxAge);
        }
        return tokenset;
    }
    get device_code() {
        return instance(this).response.device_code;
    }
    get user_code() {
        return instance(this).response.user_code;
    }
    get verification_uri() {
        return instance(this).response.verification_uri;
    }
    get verification_uri_complete() {
        return instance(this).response.verification_uri_complete;
    }
    get expires_in() {
        return Math.max.apply(null, [
            instance(this).expires_at - now(),
            0
        ]);
    }
    expired() {
        return this.expires_in === 0;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(instance(this).response, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = DeviceFlowHandle;
}}),
"[project]/node_modules/openid-client/lib/client.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable max-classes-per-file */ const { inspect } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const stdhttp = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const { strict: assert } = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const querystring = __turbopack_context__.r("[externals]/querystring [external] (querystring, cjs)");
const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const { ParseError } = __turbopack_context__.r("[project]/node_modules/got/dist/source/index.js [app-route] (ecmascript)");
const jose = __turbopack_context__.r("[project]/node_modules/jose/lib/index.js [app-route] (ecmascript)");
const tokenHash = __turbopack_context__.r("[project]/node_modules/oidc-token-hash/lib/index.js [app-route] (ecmascript)");
const base64url = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/base64url.js [app-route] (ecmascript)");
const defaults = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/defaults.js [app-route] (ecmascript)");
const { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/assert.js [app-route] (ecmascript)");
const pick = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/pick.js [app-route] (ecmascript)");
const isPlainObject = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/is_plain_object.js [app-route] (ecmascript)");
const processResponse = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/process_response.js [app-route] (ecmascript)");
const TokenSet = __turbopack_context__.r("[project]/node_modules/openid-client/lib/token_set.js [app-route] (ecmascript)");
const { OPError, RPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const now = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/unix_timestamp.js [app-route] (ecmascript)");
const { random } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/generators.js [app-route] (ecmascript)");
const request = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/request.js [app-route] (ecmascript)");
const { CALLBACK_PROPERTIES, CLIENT_DEFAULTS, JWT_CONTENT, CLOCK_TOLERANCE } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/consts.js [app-route] (ecmascript)");
const issuerRegistry = __turbopack_context__.r("[project]/node_modules/openid-client/lib/issuer_registry.js [app-route] (ecmascript)");
const instance = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/weak_cache.js [app-route] (ecmascript)");
const { authenticatedPost, resolveResponseType, resolveRedirectUri } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/client.js [app-route] (ecmascript)");
const DeviceFlowHandle = __turbopack_context__.r("[project]/node_modules/openid-client/lib/device_flow_handle.js [app-route] (ecmascript)");
function pickCb(input) {
    return pick(input, ...CALLBACK_PROPERTIES);
}
function authorizationHeaderValue(token, tokenType = 'Bearer') {
    return `${tokenType} ${token}`;
}
function cleanUpClaims(claims) {
    if (Object.keys(claims._claim_names).length === 0) {
        delete claims._claim_names;
    }
    if (Object.keys(claims._claim_sources).length === 0) {
        delete claims._claim_sources;
    }
}
function assignClaim(target, source, sourceName, throwOnMissing = true) {
    return ([claim, inSource])=>{
        if (inSource === sourceName) {
            if (throwOnMissing && source[claim] === undefined) {
                throw new RPError(`expected claim "${claim}" in "${sourceName}"`);
            } else if (source[claim] !== undefined) {
                target[claim] = source[claim];
            }
            delete target._claim_names[claim];
        }
    };
}
function verifyPresence(payload, jwt, prop) {
    if (payload[prop] === undefined) {
        throw new RPError({
            message: `missing required JWT property ${prop}`,
            jwt
        });
    }
}
function authorizationParams(params) {
    const authParams = {
        client_id: this.client_id,
        scope: 'openid',
        response_type: resolveResponseType.call(this),
        redirect_uri: resolveRedirectUri.call(this),
        ...params
    };
    Object.entries(authParams).forEach(([key, value])=>{
        if (value === null || value === undefined) {
            delete authParams[key];
        } else if (key === 'claims' && typeof value === 'object') {
            authParams[key] = JSON.stringify(value);
        } else if (key === 'resource' && Array.isArray(value)) {
            authParams[key] = value;
        } else if (typeof value !== 'string') {
            authParams[key] = String(value);
        }
    });
    return authParams;
}
async function claimJWT(label, jwt) {
    try {
        const { header, payload } = jose.JWT.decode(jwt, {
            complete: true
        });
        const { iss } = payload;
        if (header.alg === 'none') {
            return payload;
        }
        let key;
        if (!iss || iss === this.issuer.issuer) {
            key = await this.issuer.queryKeyStore(header);
        } else if (issuerRegistry.has(iss)) {
            key = await issuerRegistry.get(iss).queryKeyStore(header);
        } else {
            const discovered = await this.issuer.constructor.discover(iss);
            key = await discovered.queryKeyStore(header);
        }
        return jose.JWT.verify(jwt, key);
    } catch (err) {
        if (err instanceof RPError || err instanceof OPError || err.name === 'AggregateError') {
            throw err;
        } else {
            throw new RPError({
                printf: [
                    'failed to validate the %s JWT (%s: %s)',
                    label,
                    err.name,
                    err.message
                ],
                jwt
            });
        }
    }
}
function getKeystore(jwks) {
    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !('kty' in k))) {
        throw new TypeError('jwks must be a JSON Web Key Set formatted object');
    }
    // eslint-disable-next-line no-restricted-syntax
    for (const jwk of jwks.keys){
        if (jwk.kid === undefined) {
            jwk.kid = `DONOTUSE.${random()}`;
        }
    }
    const keystore = jose.JWKS.asKeyStore(jwks);
    if (keystore.all().some((key)=>key.type !== 'private')) {
        throw new TypeError('jwks must only contain private keys');
    }
    return keystore;
}
// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
// this is in place to take care of most common pitfalls when first using discovered Issuers without
// the support for default values defined by Discovery 1.0
function checkBasicSupport(client, metadata, properties) {
    try {
        const supported = client.issuer.token_endpoint_auth_methods_supported;
        if (!supported.includes(properties.token_endpoint_auth_method)) {
            if (supported.includes('client_secret_post')) {
                properties.token_endpoint_auth_method = 'client_secret_post';
            }
        }
    } catch (err) {}
}
function handleCommonMistakes(client, metadata, properties) {
    if (!metadata.token_endpoint_auth_method) {
        checkBasicSupport(client, metadata, properties);
    }
    // :fp: c'mon people... RTFM
    if (metadata.redirect_uri) {
        if (metadata.redirect_uris) {
            throw new TypeError('provide a redirect_uri or redirect_uris, not both');
        }
        properties.redirect_uris = [
            metadata.redirect_uri
        ];
        delete properties.redirect_uri;
    }
    if (metadata.response_type) {
        if (metadata.response_types) {
            throw new TypeError('provide a response_type or response_types, not both');
        }
        properties.response_types = [
            metadata.response_type
        ];
        delete properties.response_type;
    }
}
function getDefaultsForEndpoint(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;
    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    if (properties[eam] === undefined && properties[easa] === undefined) {
        if (tokenEndpointAuthMethod !== undefined) {
            properties[eam] = tokenEndpointAuthMethod;
        }
        if (tokenEndpointAuthSigningAlg !== undefined) {
            properties[easa] = tokenEndpointAuthSigningAlg;
        }
    }
}
class BaseClient {
}
module.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {
        /**
   * @name constructor
   * @api public
   */ constructor(metadata = {}, jwks, options){
            super();
            if (typeof metadata.client_id !== 'string' || !metadata.client_id) {
                throw new TypeError('client_id is required');
            }
            const properties = {
                ...CLIENT_DEFAULTS,
                ...metadata
            };
            handleCommonMistakes(this, metadata, properties);
            assertSigningAlgValuesSupport('token', this.issuer, properties);
            [
                'introspection',
                'revocation'
            ].forEach((endpoint)=>{
                getDefaultsForEndpoint(endpoint, this.issuer, properties);
                assertSigningAlgValuesSupport(endpoint, this.issuer, properties);
            });
            Object.entries(properties).forEach(([key, value])=>{
                instance(this).get('metadata').set(key, value);
                if (!this[key]) {
                    Object.defineProperty(this, key, {
                        get () {
                            return instance(this).get('metadata').get(key);
                        },
                        enumerable: true
                    });
                }
            });
            if (jwks !== undefined) {
                const keystore = getKeystore.call(this, jwks);
                instance(this).set('keystore', keystore);
            }
            if (options !== undefined) {
                instance(this).set('options', options);
            }
            this[CLOCK_TOLERANCE] = 0;
        }
        /**
   * @name authorizationUrl
   * @api public
   */ authorizationUrl(params = {}) {
            if (!isPlainObject(params)) {
                throw new TypeError('params must be a plain object');
            }
            assertIssuerConfiguration(this.issuer, 'authorization_endpoint');
            const target = url.parse(this.issuer.authorization_endpoint, true);
            target.search = null;
            target.query = {
                ...target.query,
                ...authorizationParams.call(this, params)
            };
            return url.format(target);
        }
        /**
   * @name authorizationPost
   * @api public
   */ authorizationPost(params = {}) {
            if (!isPlainObject(params)) {
                throw new TypeError('params must be a plain object');
            }
            const inputs = authorizationParams.call(this, params);
            const formInputs = Object.keys(inputs).map((name)=>`<input type="hidden" name="${name}" value="${inputs[name]}"/>`).join('\n');
            return `<!DOCTYPE html>
<head>
  <title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
  <form method="post" action="${this.issuer.authorization_endpoint}">
    ${formInputs}
  </form>
</body>
</html>`;
        }
        /**
   * @name endSessionUrl
   * @api public
   */ endSessionUrl(params = {}) {
            assertIssuerConfiguration(this.issuer, 'end_session_endpoint');
            const { 0: postLogout, length } = this.post_logout_redirect_uris || [];
            const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;
            let hint = params.id_token_hint;
            if (hint instanceof TokenSet) {
                if (!hint.id_token) {
                    throw new TypeError('id_token not present in TokenSet');
                }
                hint = hint.id_token;
            }
            const target = url.parse(this.issuer.end_session_endpoint, true);
            target.search = null;
            target.query = {
                ...params,
                ...target.query,
                ...{
                    post_logout_redirect_uri,
                    id_token_hint: hint
                }
            };
            Object.entries(target.query).forEach(([key, value])=>{
                if (value === null || value === undefined) {
                    delete target.query[key];
                }
            });
            return url.format(target);
        }
        /**
   * @name callbackParams
   * @api public
   */ callbackParams(input) {
            const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;
            const isString = typeof input === 'string';
            if (!isString && !isIncomingMessage) {
                throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');
            }
            if (isIncomingMessage) {
                switch(input.method){
                    case 'GET':
                        return pickCb(url.parse(input.url, true).query);
                    case 'POST':
                        if (input.body === undefined) {
                            throw new TypeError('incoming message body missing, include a body parser prior to this method call');
                        }
                        switch(typeof input.body){
                            case 'object':
                            case 'string':
                                if (Buffer.isBuffer(input.body)) {
                                    return pickCb(querystring.parse(input.body.toString('utf-8')));
                                }
                                if (typeof input.body === 'string') {
                                    return pickCb(querystring.parse(input.body));
                                }
                                return pickCb(input.body);
                            default:
                                throw new TypeError('invalid IncomingMessage body object');
                        }
                    default:
                        throw new TypeError('invalid IncomingMessage method');
                }
            } else {
                return pickCb(url.parse(input, true).query);
            }
        }
        /**
   * @name callback
   * @api public
   */ async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
            let params = pickCb(parameters);
            if (checks.jarm && !('response' in parameters)) {
                throw new RPError({
                    message: 'expected a JARM response',
                    checks,
                    params
                });
            } else if ('response' in parameters) {
                const decrypted = await this.decryptJARM(params.response);
                params = await this.validateJARM(decrypted);
            }
            if (this.default_max_age && !checks.max_age) {
                checks.max_age = this.default_max_age;
            }
            if (params.state && !checks.state) {
                throw new TypeError('checks.state argument is missing');
            }
            if (!params.state && checks.state) {
                throw new RPError({
                    message: 'state missing from the response',
                    checks,
                    params
                });
            }
            if (checks.state !== params.state) {
                throw new RPError({
                    printf: [
                        'state mismatch, expected %s, got: %s',
                        checks.state,
                        params.state
                    ],
                    checks,
                    params
                });
            }
            if (params.error) {
                throw new OPError(params);
            }
            const RESPONSE_TYPE_REQUIRED_PARAMS = {
                code: [
                    'code'
                ],
                id_token: [
                    'id_token'
                ],
                token: [
                    'access_token',
                    'token_type'
                ]
            };
            if (checks.response_type) {
                for (const type of checks.response_type.split(' ')){
                    if (type === 'none') {
                        if (params.code || params.id_token || params.access_token) {
                            throw new RPError({
                                message: 'unexpected params encountered for "none" response',
                                checks,
                                params
                            });
                        }
                    } else {
                        for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                            if (!params[param]) {
                                throw new RPError({
                                    message: `${param} missing from response`,
                                    checks,
                                    params
                                });
                            }
                        }
                    }
                }
            }
            if (params.id_token) {
                const tokenset = new TokenSet(params);
                await this.decryptIdToken(tokenset);
                await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);
                if (!params.code) {
                    return tokenset;
                }
            }
            if (params.code) {
                const tokenset = await this.grant({
                    ...exchangeBody,
                    grant_type: 'authorization_code',
                    code: params.code,
                    redirect_uri: redirectUri,
                    code_verifier: checks.code_verifier
                }, {
                    clientAssertionPayload,
                    DPoP
                });
                await this.decryptIdToken(tokenset);
                await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);
                if (params.session_state) {
                    tokenset.session_state = params.session_state;
                }
                return tokenset;
            }
            return new TokenSet(params);
        }
        /**
   * @name oauthCallback
   * @api public
   */ async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
            let params = pickCb(parameters);
            if (checks.jarm && !('response' in parameters)) {
                throw new RPError({
                    message: 'expected a JARM response',
                    checks,
                    params
                });
            } else if ('response' in parameters) {
                const decrypted = await this.decryptJARM(params.response);
                params = await this.validateJARM(decrypted);
            }
            if (params.state && !checks.state) {
                throw new TypeError('checks.state argument is missing');
            }
            if (!params.state && checks.state) {
                throw new RPError({
                    message: 'state missing from the response',
                    checks,
                    params
                });
            }
            if (checks.state !== params.state) {
                throw new RPError({
                    printf: [
                        'state mismatch, expected %s, got: %s',
                        checks.state,
                        params.state
                    ],
                    checks,
                    params
                });
            }
            if (params.error) {
                throw new OPError(params);
            }
            const RESPONSE_TYPE_REQUIRED_PARAMS = {
                code: [
                    'code'
                ],
                token: [
                    'access_token',
                    'token_type'
                ]
            };
            if (checks.response_type) {
                for (const type of checks.response_type.split(' ')){
                    if (type === 'none') {
                        if (params.code || params.id_token || params.access_token) {
                            throw new RPError({
                                message: 'unexpected params encountered for "none" response',
                                checks,
                                params
                            });
                        }
                    }
                    if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
                        for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                            if (!params[param]) {
                                throw new RPError({
                                    message: `${param} missing from response`,
                                    checks,
                                    params
                                });
                            }
                        }
                    }
                }
            }
            if (params.code) {
                return this.grant({
                    ...exchangeBody,
                    grant_type: 'authorization_code',
                    code: params.code,
                    redirect_uri: redirectUri,
                    code_verifier: checks.code_verifier
                }, {
                    clientAssertionPayload,
                    DPoP
                });
            }
            return new TokenSet(params);
        }
        /**
   * @name decryptIdToken
   * @api private
   */ async decryptIdToken(token) {
            if (!this.id_token_encrypted_response_alg) {
                return token;
            }
            let idToken = token;
            if (idToken instanceof TokenSet) {
                if (!idToken.id_token) {
                    throw new TypeError('id_token not present in TokenSet');
                }
                idToken = idToken.id_token;
            }
            const expectedAlg = this.id_token_encrypted_response_alg;
            const expectedEnc = this.id_token_encrypted_response_enc;
            const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);
            if (token instanceof TokenSet) {
                token.id_token = result;
                return token;
            }
            return result;
        }
        async validateJWTUserinfo(body) {
            const expectedAlg = this.userinfo_signed_response_alg;
            return this.validateJWT(body, expectedAlg, []);
        }
        /**
   * @name decryptJARM
   * @api private
   */ async decryptJARM(response) {
            if (!this.authorization_encrypted_response_alg) {
                return response;
            }
            const expectedAlg = this.authorization_encrypted_response_alg;
            const expectedEnc = this.authorization_encrypted_response_enc;
            return this.decryptJWE(response, expectedAlg, expectedEnc);
        }
        /**
   * @name decryptJWTUserinfo
   * @api private
   */ async decryptJWTUserinfo(body) {
            if (!this.userinfo_encrypted_response_alg) {
                return body;
            }
            const expectedAlg = this.userinfo_encrypted_response_alg;
            const expectedEnc = this.userinfo_encrypted_response_enc;
            return this.decryptJWE(body, expectedAlg, expectedEnc);
        }
        /**
   * @name decryptJWE
   * @api private
   */ async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {
            const header = JSON.parse(base64url.decode(jwe.split('.')[0]));
            if (header.alg !== expectedAlg) {
                throw new RPError({
                    printf: [
                        'unexpected JWE alg received, expected %s, got: %s',
                        expectedAlg,
                        header.alg
                    ],
                    jwt: jwe
                });
            }
            if (header.enc !== expectedEnc) {
                throw new RPError({
                    printf: [
                        'unexpected JWE enc received, expected %s, got: %s',
                        expectedEnc,
                        header.enc
                    ],
                    jwt: jwe
                });
            }
            let keyOrStore;
            if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
                keyOrStore = instance(this).get('keystore');
            } else {
                keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);
            }
            const payload = jose.JWE.decrypt(jwe, keyOrStore);
            return payload.toString('utf8');
        }
        /**
   * @name validateIdToken
   * @api private
   */ async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {
            let idToken = tokenSet;
            const expectedAlg = this.id_token_signed_response_alg;
            const isTokenSet = idToken instanceof TokenSet;
            if (isTokenSet) {
                if (!idToken.id_token) {
                    throw new TypeError('id_token not present in TokenSet');
                }
                idToken = idToken.id_token;
            }
            idToken = String(idToken);
            const timestamp = now();
            const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);
            if (maxAge || maxAge !== null && this.require_auth_time) {
                if (!payload.auth_time) {
                    throw new RPError({
                        message: 'missing required JWT property auth_time',
                        jwt: idToken
                    });
                }
                if (typeof payload.auth_time !== 'number') {
                    throw new RPError({
                        message: 'JWT auth_time claim must be a JSON numeric value',
                        jwt: idToken
                    });
                }
            }
            if (maxAge && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {
                throw new RPError({
                    printf: [
                        'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',
                        maxAge,
                        payload.auth_time,
                        timestamp - this[CLOCK_TOLERANCE]
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    auth_time: payload.auth_time,
                    jwt: idToken
                });
            }
            if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {
                throw new RPError({
                    printf: [
                        'nonce mismatch, expected %s, got: %s',
                        nonce,
                        payload.nonce
                    ],
                    jwt: idToken
                });
            }
            const fapi = this.constructor.name === 'FAPIClient';
            if (returnedBy === 'authorization') {
                if (!payload.at_hash && tokenSet.access_token) {
                    throw new RPError({
                        message: 'missing required property at_hash',
                        jwt: idToken
                    });
                }
                if (!payload.c_hash && tokenSet.code) {
                    throw new RPError({
                        message: 'missing required property c_hash',
                        jwt: idToken
                    });
                }
                if (fapi) {
                    if (!payload.s_hash && (tokenSet.state || state)) {
                        throw new RPError({
                            message: 'missing required property s_hash',
                            jwt: idToken
                        });
                    }
                }
                if (payload.s_hash) {
                    if (!state) {
                        throw new TypeError('cannot verify s_hash, "checks.state" property not provided');
                    }
                    try {
                        tokenHash.validate({
                            claim: 's_hash',
                            source: 'state'
                        }, payload.s_hash, state, header.alg, key && key.crv);
                    } catch (err) {
                        throw new RPError({
                            message: err.message,
                            jwt: idToken
                        });
                    }
                }
            }
            if (fapi && payload.iat < timestamp - 3600) {
                throw new RPError({
                    printf: [
                        'JWT issued too far in the past, now %i, iat %i',
                        timestamp,
                        payload.iat
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    iat: payload.iat,
                    jwt: idToken
                });
            }
            if (tokenSet.access_token && payload.at_hash !== undefined) {
                try {
                    tokenHash.validate({
                        claim: 'at_hash',
                        source: 'access_token'
                    }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);
                } catch (err) {
                    throw new RPError({
                        message: err.message,
                        jwt: idToken
                    });
                }
            }
            if (tokenSet.code && payload.c_hash !== undefined) {
                try {
                    tokenHash.validate({
                        claim: 'c_hash',
                        source: 'code'
                    }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);
                } catch (err) {
                    throw new RPError({
                        message: err.message,
                        jwt: idToken
                    });
                }
            }
            return tokenSet;
        }
        /**
   * @name validateJWT
   * @api private
   */ async validateJWT(jwt, expectedAlg, required = [
            'iss',
            'sub',
            'aud',
            'exp',
            'iat'
        ]) {
            const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';
            const timestamp = now();
            let header;
            let payload;
            try {
                ({ header, payload } = jose.JWT.decode(jwt, {
                    complete: true
                }));
            } catch (err) {
                throw new RPError({
                    printf: [
                        'failed to decode JWT (%s: %s)',
                        err.name,
                        err.message
                    ],
                    jwt
                });
            }
            if (header.alg !== expectedAlg) {
                throw new RPError({
                    printf: [
                        'unexpected JWT alg received, expected %s, got: %s',
                        expectedAlg,
                        header.alg
                    ],
                    jwt
                });
            }
            if (isSelfIssued) {
                required = [
                    ...required,
                    'sub_jwk'
                ]; // eslint-disable-line no-param-reassign
            }
            required.forEach(verifyPresence.bind(undefined, payload, jwt));
            if (payload.iss !== undefined) {
                let expectedIss = this.issuer.issuer;
                if (aadIssValidation) {
                    expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);
                }
                if (payload.iss !== expectedIss) {
                    throw new RPError({
                        printf: [
                            'unexpected iss value, expected %s, got: %s',
                            expectedIss,
                            payload.iss
                        ],
                        jwt
                    });
                }
            }
            if (payload.iat !== undefined) {
                if (typeof payload.iat !== 'number') {
                    throw new RPError({
                        message: 'JWT iat claim must be a JSON numeric value',
                        jwt
                    });
                }
            }
            if (payload.nbf !== undefined) {
                if (typeof payload.nbf !== 'number') {
                    throw new RPError({
                        message: 'JWT nbf claim must be a JSON numeric value',
                        jwt
                    });
                }
                if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {
                    throw new RPError({
                        printf: [
                            'JWT not active yet, now %i, nbf %i',
                            timestamp + this[CLOCK_TOLERANCE],
                            payload.nbf
                        ],
                        now: timestamp,
                        tolerance: this[CLOCK_TOLERANCE],
                        nbf: payload.nbf,
                        jwt
                    });
                }
            }
            if (payload.exp !== undefined) {
                if (typeof payload.exp !== 'number') {
                    throw new RPError({
                        message: 'JWT exp claim must be a JSON numeric value',
                        jwt
                    });
                }
                if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {
                    throw new RPError({
                        printf: [
                            'JWT expired, now %i, exp %i',
                            timestamp - this[CLOCK_TOLERANCE],
                            payload.exp
                        ],
                        now: timestamp,
                        tolerance: this[CLOCK_TOLERANCE],
                        exp: payload.exp,
                        jwt
                    });
                }
            }
            if (payload.aud !== undefined) {
                if (Array.isArray(payload.aud)) {
                    if (payload.aud.length > 1 && !payload.azp) {
                        throw new RPError({
                            message: 'missing required JWT property azp',
                            jwt
                        });
                    }
                    if (!payload.aud.includes(this.client_id)) {
                        throw new RPError({
                            printf: [
                                'aud is missing the client_id, expected %s to be included in %j',
                                this.client_id,
                                payload.aud
                            ],
                            jwt
                        });
                    }
                } else if (payload.aud !== this.client_id) {
                    throw new RPError({
                        printf: [
                            'aud mismatch, expected %s, got: %s',
                            this.client_id,
                            payload.aud
                        ],
                        jwt
                    });
                }
            }
            if (payload.azp !== undefined) {
                let { additionalAuthorizedParties } = instance(this).get('options') || {};
                if (typeof additionalAuthorizedParties === 'string') {
                    additionalAuthorizedParties = [
                        this.client_id,
                        additionalAuthorizedParties
                    ];
                } else if (Array.isArray(additionalAuthorizedParties)) {
                    additionalAuthorizedParties = [
                        this.client_id,
                        ...additionalAuthorizedParties
                    ];
                } else {
                    additionalAuthorizedParties = [
                        this.client_id
                    ];
                }
                if (!additionalAuthorizedParties.includes(payload.azp)) {
                    throw new RPError({
                        printf: [
                            'azp mismatch, got: %s',
                            payload.azp
                        ],
                        jwt
                    });
                }
            }
            let key;
            if (isSelfIssued) {
                try {
                    assert(isPlainObject(payload.sub_jwk));
                    key = jose.JWK.asKey(payload.sub_jwk);
                    assert.equal(key.type, 'public');
                } catch (err) {
                    throw new RPError({
                        message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',
                        jwt
                    });
                }
                if (key.thumbprint !== payload.sub) {
                    throw new RPError({
                        message: 'failed to match the subject with sub_jwk',
                        jwt
                    });
                }
            } else if (header.alg.startsWith('HS')) {
                key = await this.joseSecret();
            } else if (header.alg !== 'none') {
                key = await this.issuer.queryKeyStore(header);
            }
            if (!key && header.alg === 'none') {
                return {
                    protected: header,
                    payload
                };
            }
            try {
                return {
                    ...jose.JWS.verify(jwt, key, {
                        complete: true
                    }),
                    payload
                };
            } catch (err) {
                throw new RPError({
                    message: 'failed to validate JWT signature',
                    jwt
                });
            }
        }
        /**
   * @name refresh
   * @api public
   */ async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
            let token = refreshToken;
            if (token instanceof TokenSet) {
                if (!token.refresh_token) {
                    throw new TypeError('refresh_token not present in TokenSet');
                }
                token = token.refresh_token;
            }
            const tokenset = await this.grant({
                ...exchangeBody,
                grant_type: 'refresh_token',
                refresh_token: String(token)
            }, {
                clientAssertionPayload,
                DPoP
            });
            if (tokenset.id_token) {
                await this.decryptIdToken(tokenset);
                await this.validateIdToken(tokenset, null, 'token', null);
                if (refreshToken instanceof TokenSet && refreshToken.id_token) {
                    const expectedSub = refreshToken.claims().sub;
                    const actualSub = tokenset.claims().sub;
                    if (actualSub !== expectedSub) {
                        throw new RPError({
                            printf: [
                                'sub mismatch, expected %s, got: %s',
                                expectedSub,
                                actualSub
                            ],
                            jwt: tokenset.id_token
                        });
                    }
                }
            }
            return tokenset;
        }
        async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, // eslint-disable-next-line no-nested-ternary
        tokenType = DPoP ? 'DPoP' : accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer' } = {}) {
            if (accessToken instanceof TokenSet) {
                if (!accessToken.access_token) {
                    throw new TypeError('access_token not present in TokenSet');
                }
                accessToken = accessToken.access_token; // eslint-disable-line no-param-reassign
            }
            const requestOpts = {
                headers: {
                    Authorization: authorizationHeaderValue(accessToken, tokenType),
                    ...headers
                },
                body
            };
            const mTLS = !!this.tls_client_certificate_bound_access_tokens;
            return request.call(this, {
                ...requestOpts,
                responseType: 'buffer',
                method,
                url: resourceUrl
            }, {
                accessToken,
                mTLS,
                DPoP
            });
        }
        /**
   * @name userinfo
   * @api public
   */ async userinfo(accessToken, { method = 'GET', via = 'header', tokenType, params, DPoP } = {}) {
            assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');
            const options = {
                tokenType,
                method: String(method).toUpperCase(),
                DPoP
            };
            if (options.method !== 'GET' && options.method !== 'POST') {
                throw new TypeError('#userinfo() method can only be POST or a GET');
            }
            if (via === 'query' && options.method !== 'GET') {
                throw new TypeError('userinfo endpoints will only parse query strings for GET requests');
            } else if (via === 'body' && options.method !== 'POST') {
                throw new TypeError('can only send body on POST');
            }
            const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);
            if (jwt) {
                options.headers = {
                    Accept: 'application/jwt'
                };
            } else {
                options.headers = {
                    Accept: 'application/json'
                };
            }
            const mTLS = !!this.tls_client_certificate_bound_access_tokens;
            let targetUrl;
            if (mTLS && this.issuer.mtls_endpoint_aliases) {
                targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;
            }
            targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);
            // when via is not header we clear the Authorization header and add either
            // query string parameters or urlencoded body access_token parameter
            if (via === 'query') {
                options.headers.Authorization = undefined;
                targetUrl.searchParams.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);
            } else if (via === 'body') {
                options.headers.Authorization = undefined;
                options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                options.body = new url.URLSearchParams();
                options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);
            }
            // handle additional parameters, GET via querystring, POST via urlencoded body
            if (params) {
                if (options.method === 'GET') {
                    Object.entries(params).forEach(([key, value])=>{
                        targetUrl.searchParams.append(key, value);
                    });
                } else if (options.body) {
                    Object.entries(params).forEach(([key, value])=>{
                        options.body.append(key, value);
                    });
                } else {
                    options.body = new url.URLSearchParams();
                    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    Object.entries(params).forEach(([key, value])=>{
                        options.body.append(key, value);
                    });
                }
            }
            if (options.body) {
                options.body = options.body.toString();
            }
            const response = await this.requestResource(targetUrl, accessToken, options);
            let parsed = processResponse(response, {
                bearer: true
            });
            if (jwt) {
                if (!JWT_CONTENT.test(response.headers['content-type'])) {
                    throw new RPError({
                        message: 'expected application/jwt response from the userinfo_endpoint',
                        response
                    });
                }
                const body = response.body.toString();
                const userinfo = await this.decryptJWTUserinfo(body);
                if (!this.userinfo_signed_response_alg) {
                    try {
                        parsed = JSON.parse(userinfo);
                        assert(isPlainObject(parsed));
                    } catch (err) {
                        throw new RPError({
                            message: 'failed to parse userinfo JWE payload as JSON',
                            jwt: userinfo
                        });
                    }
                } else {
                    ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));
                }
            } else {
                try {
                    parsed = JSON.parse(response.body);
                } catch (error) {
                    throw new ParseError(error, response);
                }
            }
            if (accessToken instanceof TokenSet && accessToken.id_token) {
                const expectedSub = accessToken.claims().sub;
                if (parsed.sub !== expectedSub) {
                    throw new RPError({
                        printf: [
                            'userinfo sub mismatch, expected %s, got: %s',
                            expectedSub,
                            parsed.sub
                        ],
                        body: parsed,
                        jwt: accessToken.id_token
                    });
                }
            }
            return parsed;
        }
        /**
   * @name derivedKey
   * @api private
   */ async derivedKey(len) {
            const cacheKey = `${len}_key`;
            if (instance(this).has(cacheKey)) {
                return instance(this).get(cacheKey);
            }
            const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false; // eslint-disable-line no-nested-ternary
            if (!hash) {
                throw new Error('unsupported symmetric encryption key derivation');
            }
            const derivedBuffer = crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);
            const key = jose.JWK.asKey({
                k: base64url.encode(derivedBuffer),
                kty: 'oct'
            });
            instance(this).set(cacheKey, key);
            return key;
        }
        /**
   * @name joseSecret
   * @api private
   */ async joseSecret(alg) {
            if (!this.client_secret) {
                throw new TypeError('client_secret is required');
            }
            if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
                return this.derivedKey(parseInt(RegExp.$1, 10));
            }
            if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
                return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));
            }
            if (instance(this).has('jose_secret')) {
                return instance(this).get('jose_secret');
            }
            const key = jose.JWK.asKey({
                k: base64url.encode(this.client_secret),
                kty: 'oct'
            });
            instance(this).set('jose_secret', key);
            return key;
        }
        /**
   * @name grant
   * @api public
   */ async grant(body, { clientAssertionPayload, DPoP } = {}) {
            assertIssuerConfiguration(this.issuer, 'token_endpoint');
            const response = await authenticatedPost.call(this, 'token', {
                form: body,
                responseType: 'json'
            }, {
                clientAssertionPayload,
                DPoP
            });
            const responseBody = processResponse(response);
            return new TokenSet(responseBody);
        }
        /**
   * @name deviceAuthorization
   * @api public
   */ async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
            assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');
            assertIssuerConfiguration(this.issuer, 'token_endpoint');
            const body = authorizationParams.call(this, {
                client_id: this.client_id,
                redirect_uri: null,
                response_type: null,
                ...params
            });
            const response = await authenticatedPost.call(this, 'device_authorization', {
                responseType: 'json',
                form: body
            }, {
                clientAssertionPayload,
                endpointAuthMethod: 'token'
            });
            const responseBody = processResponse(response);
            return new DeviceFlowHandle({
                client: this,
                exchangeBody,
                clientAssertionPayload,
                response: responseBody,
                maxAge: params.max_age,
                DPoP
            });
        }
        /**
   * @name revoke
   * @api public
   */ async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {
            assertIssuerConfiguration(this.issuer, 'revocation_endpoint');
            if (hint !== undefined && typeof hint !== 'string') {
                throw new TypeError('hint must be a string');
            }
            const form = {
                ...revokeBody,
                token
            };
            if (hint) {
                form.token_type_hint = hint;
            }
            const response = await authenticatedPost.call(this, 'revocation', {
                form
            }, {
                clientAssertionPayload
            });
            processResponse(response, {
                body: false
            });
        }
        /**
   * @name introspect
   * @api public
   */ async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {
            assertIssuerConfiguration(this.issuer, 'introspection_endpoint');
            if (hint !== undefined && typeof hint !== 'string') {
                throw new TypeError('hint must be a string');
            }
            const form = {
                ...introspectBody,
                token
            };
            if (hint) {
                form.token_type_hint = hint;
            }
            const response = await authenticatedPost.call(this, 'introspection', {
                form,
                responseType: 'json'
            }, {
                clientAssertionPayload
            });
            const responseBody = processResponse(response);
            return responseBody;
        }
        /**
   * @name fetchDistributedClaims
   * @api public
   */ async fetchDistributedClaims(claims, tokens = {}) {
            if (!isPlainObject(claims)) {
                throw new TypeError('claims argument must be a plain object');
            }
            if (!isPlainObject(claims._claim_sources)) {
                return claims;
            }
            if (!isPlainObject(claims._claim_names)) {
                return claims;
            }
            const distributedSources = Object.entries(claims._claim_sources).filter(([, value])=>value && value.endpoint);
            await Promise.all(distributedSources.map(async ([sourceName, def])=>{
                try {
                    const requestOpts = {
                        headers: {
                            Accept: 'application/jwt',
                            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName])
                        }
                    };
                    const response = await request.call(this, {
                        ...requestOpts,
                        method: 'GET',
                        url: def.endpoint
                    });
                    const body = processResponse(response, {
                        bearer: true
                    });
                    const decoded = await claimJWT.call(this, 'distributed', body);
                    delete claims._claim_sources[sourceName];
                    Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName, false));
                } catch (err) {
                    err.src = sourceName;
                    throw err;
                }
            }));
            cleanUpClaims(claims);
            return claims;
        }
        /**
   * @name unpackAggregatedClaims
   * @api public
   */ async unpackAggregatedClaims(claims) {
            if (!isPlainObject(claims)) {
                throw new TypeError('claims argument must be a plain object');
            }
            if (!isPlainObject(claims._claim_sources)) {
                return claims;
            }
            if (!isPlainObject(claims._claim_names)) {
                return claims;
            }
            const aggregatedSources = Object.entries(claims._claim_sources).filter(([, value])=>value && value.JWT);
            await Promise.all(aggregatedSources.map(async ([sourceName, def])=>{
                try {
                    const decoded = await claimJWT.call(this, 'aggregated', def.JWT);
                    delete claims._claim_sources[sourceName];
                    Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));
                } catch (err) {
                    err.src = sourceName;
                    throw err;
                }
            }));
            cleanUpClaims(claims);
            return claims;
        }
        /**
   * @name register
   * @api public
   */ static async register(metadata, options = {}) {
            const { initialAccessToken, jwks, ...clientOptions } = options;
            assertIssuerConfiguration(this.issuer, 'registration_endpoint');
            if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {
                const keystore = getKeystore.call(this, jwks);
                metadata.jwks = keystore.toJWKS(false);
                // eslint-disable-next-line no-restricted-syntax
                for (const jwk of metadata.jwks.keys){
                    if (jwk.kid.startsWith('DONOTUSE.')) {
                        delete jwk.kid;
                    }
                }
            }
            const response = await request.call(this, {
                headers: initialAccessToken ? {
                    Authorization: authorizationHeaderValue(initialAccessToken)
                } : undefined,
                responseType: 'json',
                json: metadata,
                url: this.issuer.registration_endpoint,
                method: 'POST'
            });
            const responseBody = processResponse(response, {
                statusCode: 201,
                bearer: true
            });
            return new this(responseBody, jwks, clientOptions);
        }
        /**
   * @name metadata
   * @api public
   */ get metadata() {
            const copy = {};
            instance(this).get('metadata').forEach((value, key)=>{
                copy[key] = value;
            });
            return copy;
        }
        /**
   * @name fromUri
   * @api public
   */ static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {
            const response = await request.call(this, {
                method: 'GET',
                url: registrationClientUri,
                responseType: 'json',
                headers: {
                    Authorization: authorizationHeaderValue(registrationAccessToken)
                }
            });
            const responseBody = processResponse(response, {
                bearer: true
            });
            return new this(responseBody, jwks, clientOptions);
        }
        /**
   * @name requestObject
   * @api public
   */ async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || 'none', encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256' } = {} } = {}) {
            if (!isPlainObject(requestObject)) {
                throw new TypeError('requestObject must be a plain object');
            }
            let signed;
            let key;
            const fapi = this.constructor.name === 'FAPIClient';
            const unix = now();
            const header = {
                alg: signingAlgorithm,
                typ: 'oauth-authz-req+jwt'
            };
            const payload = JSON.stringify(defaults({}, requestObject, {
                iss: this.client_id,
                aud: this.issuer.issuer,
                client_id: this.client_id,
                jti: random(),
                iat: unix,
                exp: unix + 300,
                ...fapi ? {
                    nbf: unix
                } : undefined
            }));
            if (signingAlgorithm === 'none') {
                signed = [
                    base64url.encode(JSON.stringify(header)),
                    base64url.encode(payload),
                    ''
                ].join('.');
            } else {
                const symmetric = signingAlgorithm.startsWith('HS');
                if (symmetric) {
                    key = await this.joseSecret();
                } else {
                    const keystore = instance(this).get('keystore');
                    if (!keystore) {
                        throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);
                    }
                    key = keystore.get({
                        alg: signingAlgorithm,
                        use: 'sig'
                    });
                    if (!key) {
                        throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);
                    }
                }
                signed = jose.JWS.sign(payload, key, {
                    ...header,
                    kid: symmetric || key.kid.startsWith('DONOTUSE.') ? undefined : key.kid
                });
            }
            if (!eKeyManagement) {
                return signed;
            }
            const fields = {
                alg: eKeyManagement,
                enc: eContentEncryption,
                cty: 'oauth-authz-req+jwt'
            };
            if (fields.alg.match(/^(RSA|ECDH)/)) {
                [key] = await this.issuer.queryKeyStore({
                    alg: fields.alg,
                    enc: fields.enc,
                    use: 'enc'
                }, {
                    allowMulti: true
                });
            } else {
                key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);
            }
            return jose.JWE.encrypt(signed, key, {
                ...fields,
                kid: key.kty === 'oct' ? undefined : key.kid
            });
        }
        /**
   * @name pushedAuthorizationRequest
   * @api public
   */ async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {
            assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');
            const body = {
                ...'request' in params ? params : authorizationParams.call(this, params),
                client_id: this.client_id
            };
            const response = await authenticatedPost.call(this, 'pushed_authorization_request', {
                responseType: 'json',
                form: body
            }, {
                clientAssertionPayload,
                endpointAuthMethod: 'token'
            });
            const responseBody = processResponse(response, {
                statusCode: 201
            });
            if (!('expires_in' in responseBody)) {
                throw new RPError({
                    message: 'expected expires_in in Pushed Authorization Successful Response',
                    response
                });
            }
            if (typeof responseBody.expires_in !== 'number') {
                throw new RPError({
                    message: 'invalid expires_in value in Pushed Authorization Successful Response',
                    response
                });
            }
            if (!('request_uri' in responseBody)) {
                throw new RPError({
                    message: 'expected request_uri in Pushed Authorization Successful Response',
                    response
                });
            }
            if (typeof responseBody.request_uri !== 'string') {
                throw new RPError({
                    message: 'invalid request_uri value in Pushed Authorization Successful Response',
                    response
                });
            }
            return responseBody;
        }
        /**
   * @name issuer
   * @api public
   */ static get issuer() {
            return issuer;
        }
        /**
   * @name issuer
   * @api public
   */ get issuer() {
            return issuer;
        }
        /* istanbul ignore next */ [inspect.custom]() {
            return `${this.constructor.name} ${inspect(this.metadata, {
                depth: Infinity,
                colors: process.stdout.isTTY,
                compact: false,
                sorted: true
            })}`;
        }
    };
/**
 * @name validateJARM
 * @api private
 */ async function validateJARM(response) {
    const expectedAlg = this.authorization_signed_response_alg;
    const { payload } = await this.validateJWT(response, expectedAlg, [
        'iss',
        'exp',
        'aud'
    ]);
    return pickCb(payload);
}
Object.defineProperty(BaseClient.prototype, 'validateJARM', {
    enumerable: true,
    configurable: true,
    value (...args) {
        process.emitWarning("The JARM API implements an OIDF implementer's draft. Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.", 'DraftWarning');
        Object.defineProperty(BaseClient.prototype, 'validateJARM', {
            enumerable: true,
            configurable: true,
            value: validateJARM
        });
        return this.validateJARM(...args);
    }
});
/**
 * @name dpopProof
 * @api private
 */ function dpopProof(payload, jwk, accessToken) {
    if (!isPlainObject(payload)) {
        throw new TypeError('payload must be a plain object');
    }
    let key;
    try {
        key = jose.JWK.asKey(jwk);
        assert(key.type === 'private');
    } catch (err) {
        throw new TypeError('"DPoP" option must be an asymmetric private key to sign the DPoP Proof JWT with');
    }
    let { alg } = key;
    if (!alg && this.issuer.dpop_signing_alg_values_supported) {
        const algs = key.algorithms('sign');
        alg = this.issuer.dpop_signing_alg_values_supported.find((a)=>algs.has(a));
    }
    if (!alg) {
        [alg] = key.algorithms('sign');
    }
    return jose.JWS.sign({
        iat: now(),
        jti: random(),
        ath: accessToken ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest()) : undefined,
        ...payload
    }, jwk, {
        alg,
        typ: 'dpop+jwt',
        jwk: pick(key, 'kty', 'crv', 'x', 'y', 'e', 'n')
    });
}
Object.defineProperty(BaseClient.prototype, 'dpopProof', {
    enumerable: true,
    configurable: true,
    value (...args) {
        process.emitWarning('The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-03.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.', 'DraftWarning');
        Object.defineProperty(BaseClient.prototype, 'dpopProof', {
            enumerable: true,
            configurable: true,
            value: dpopProof
        });
        return this.dpopProof(...args);
    }
});
module.exports.BaseClient = BaseClient;
}}),
"[project]/node_modules/openid-client/lib/helpers/webfinger_normalize.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py
// -- Normalization --
// A string of any other type is interpreted as a URI either the form of scheme
// "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
// normalized according to the following rules:
//
// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
// portion, the string is interpreted as [userinfo "@"] host [":" port]
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
// If the userinfo component is present and all of the path component, query
// component, and port component are empty, the acct scheme is assumed. In this
// case, the normalized URI is formed by prefixing acct: to the string as the
// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an
// at-sign character ('@') in the userinfo component, it needs to be
// percent-encoded as described in RFC 3986 [RFC3986].
// For all other inputs without a scheme portion, the https scheme is assumed,
// and the normalized URI is formed by prefixing https:// to the string as the
// scheme.
// If the resulting URI contains a fragment portion, it MUST be stripped off
// together with the fragment delimiter character "#".
// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the
// resulting URI, and the WebFinger Host is the authority component.
//
// Note: Since the definition of authority in RFC 3986 [RFC3986] is
// [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
// identifier like userinfo@host:port, e.g., alice@example.com:8080.
const PORT = /^\d+$/;
function hasScheme(input) {
    if (input.includes('://')) return true;
    const authority = input.replace(/(\/|\?)/g, '#').split('#')[0];
    if (authority.includes(':')) {
        const index = authority.indexOf(':');
        const hostOrPort = authority.slice(index + 1);
        if (!PORT.test(hostOrPort)) {
            return true;
        }
    }
    return false;
}
function acctSchemeAssumed(input) {
    if (!input.includes('@')) return false;
    const parts = input.split('@');
    const host = parts[parts.length - 1];
    return !(host.includes(':') || host.includes('/') || host.includes('?'));
}
function normalize(input) {
    if (typeof input !== 'string') {
        throw new TypeError('input must be a string');
    }
    let output;
    if (hasScheme(input)) {
        output = input;
    } else if (acctSchemeAssumed(input)) {
        output = `acct:${input}`;
    } else {
        output = `https://${input}`;
    }
    return output.split('#')[0];
}
module.exports = normalize;
}}),
"[project]/node_modules/openid-client/lib/issuer.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable max-classes-per-file */ const { inspect } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const AggregateError = __turbopack_context__.r("[project]/node_modules/aggregate-error/index.js [app-route] (ecmascript)");
const jose = __turbopack_context__.r("[project]/node_modules/jose/lib/index.js [app-route] (ecmascript)");
const LRU = __turbopack_context__.r("[project]/node_modules/openid-client/node_modules/lru-cache/index.js [app-route] (ecmascript)");
const objectHash = __turbopack_context__.r("[project]/node_modules/object-hash/index.js [app-route] (ecmascript)");
const { RPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const getClient = __turbopack_context__.r("[project]/node_modules/openid-client/lib/client.js [app-route] (ecmascript)");
const registry = __turbopack_context__.r("[project]/node_modules/openid-client/lib/issuer_registry.js [app-route] (ecmascript)");
const processResponse = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/process_response.js [app-route] (ecmascript)");
const webfingerNormalize = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/webfinger_normalize.js [app-route] (ecmascript)");
const instance = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/weak_cache.js [app-route] (ecmascript)");
const request = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/request.js [app-route] (ecmascript)");
const { assertIssuerConfiguration } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/assert.js [app-route] (ecmascript)");
const { ISSUER_DEFAULTS, OIDC_DISCOVERY, OAUTH2_DISCOVERY, WEBFINGER, REL, AAD_MULTITENANT_DISCOVERY } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/consts.js [app-route] (ecmascript)");
const AAD_MULTITENANT = Symbol('AAD_MULTITENANT');
class Issuer {
    /**
   * @name constructor
   * @api public
   */ constructor(meta = {}){
        const aadIssValidation = meta[AAD_MULTITENANT];
        delete meta[AAD_MULTITENANT];
        [
            'introspection',
            'revocation'
        ].forEach((endpoint)=>{
            // if intro/revocation endpoint auth specific meta is missing use the token ones if they
            // are defined
            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {
                if (meta.token_endpoint_auth_methods_supported) {
                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;
                }
                if (meta.token_endpoint_auth_signing_alg_values_supported) {
                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;
                }
            }
        });
        Object.entries(meta).forEach(([key, value])=>{
            instance(this).get('metadata').set(key, value);
            if (!this[key]) {
                Object.defineProperty(this, key, {
                    get () {
                        return instance(this).get('metadata').get(key);
                    },
                    enumerable: true
                });
            }
        });
        instance(this).set('cache', new LRU({
            max: 100
        }));
        registry.set(this.issuer, this);
        const Client = getClient(this, aadIssValidation);
        Object.defineProperties(this, {
            Client: {
                value: Client
            },
            FAPIClient: {
                value: class FAPIClient extends Client {
                }
            }
        });
    }
    /**
   * @name keystore
   * @api public
   */ async keystore(reload = false) {
        assertIssuerConfiguration(this, 'jwks_uri');
        const keystore = instance(this).get('keystore');
        const cache = instance(this).get('cache');
        if (reload || !keystore) {
            cache.reset();
            const response = await request.call(this, {
                method: 'GET',
                responseType: 'json',
                url: this.jwks_uri
            });
            const jwks = processResponse(response);
            const joseKeyStore = jose.JWKS.asKeyStore(jwks, {
                ignoreErrors: true
            });
            cache.set('throttle', true, 60 * 1000);
            instance(this).set('keystore', joseKeyStore);
            return joseKeyStore;
        }
        return keystore;
    }
    /**
   * @name queryKeyStore
   * @api private
   */ async queryKeyStore({ kid, kty, alg, use, key_ops: ops }, { allowMulti = false } = {}) {
        const cache = instance(this).get('cache');
        const def = {
            kid,
            kty,
            alg,
            use,
            key_ops: ops
        };
        const defHash = objectHash(def, {
            algorithm: 'sha256',
            ignoreUnknown: true,
            unorderedArrays: true,
            unorderedSets: true
        });
        // refresh keystore on every unknown key but also only upto once every minute
        const freshJwksUri = cache.get(defHash) || cache.get('throttle');
        const keystore = await this.keystore(!freshJwksUri);
        const keys = keystore.all(def);
        if (keys.length === 0) {
            throw new RPError({
                printf: [
                    "no valid key found in issuer's jwks_uri for key parameters %j",
                    def
                ],
                jwks: keystore
            });
        }
        if (!allowMulti && keys.length > 1 && !kid) {
            throw new RPError({
                printf: [
                    "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                    def
                ],
                jwks: keystore
            });
        }
        cache.set(defHash, true);
        return new jose.JWKS.KeyStore(keys);
    }
    /**
   * @name metadata
   * @api public
   */ get metadata() {
        const copy = {};
        instance(this).get('metadata').forEach((value, key)=>{
            copy[key] = value;
        });
        return copy;
    }
    /**
   * @name webfinger
   * @api public
   */ static async webfinger(input) {
        const resource = webfingerNormalize(input);
        const { host } = url.parse(resource);
        const webfingerUrl = `https://${host}${WEBFINGER}`;
        const response = await request.call(this, {
            method: 'GET',
            url: webfingerUrl,
            responseType: 'json',
            searchParams: {
                resource,
                rel: REL
            },
            followRedirect: true
        });
        const body = processResponse(response);
        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === 'object' && link.rel === REL && link.href);
        if (!location) {
            throw new RPError({
                message: 'no issuer found in webfinger response',
                body
            });
        }
        if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {
            throw new RPError({
                printf: [
                    'invalid issuer location %s',
                    location.href
                ],
                body
            });
        }
        const expectedIssuer = location.href;
        if (registry.has(expectedIssuer)) {
            return registry.get(expectedIssuer);
        }
        const issuer = await this.discover(expectedIssuer);
        if (issuer.issuer !== expectedIssuer) {
            registry.delete(issuer.issuer);
            throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);
        }
        return issuer;
    }
    /**
   * @name discover
   * @api public
   */ static async discover(uri) {
        const parsed = url.parse(uri);
        if (parsed.pathname.includes('/.well-known/')) {
            const response = await request.call(this, {
                method: 'GET',
                responseType: 'json',
                url: uri
            });
            const body = processResponse(response);
            return new Issuer({
                ...ISSUER_DEFAULTS,
                ...body,
                [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>uri.startsWith(discoveryURL))
            });
        }
        const pathnames = [];
        if (parsed.pathname.endsWith('/')) {
            pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`);
        } else {
            pathnames.push(`${parsed.pathname}${OIDC_DISCOVERY}`);
        }
        if (parsed.pathname === '/') {
            pathnames.push(`${OAUTH2_DISCOVERY}`);
        } else {
            pathnames.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`);
        }
        const errors = [];
        // eslint-disable-next-line no-restricted-syntax
        for (const pathname of pathnames){
            try {
                const wellKnownUri = url.format({
                    ...parsed,
                    pathname
                });
                // eslint-disable-next-line no-await-in-loop
                const response = await request.call(this, {
                    method: 'GET',
                    responseType: 'json',
                    url: wellKnownUri
                });
                const body = processResponse(response);
                return new Issuer({
                    ...ISSUER_DEFAULTS,
                    ...body,
                    [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))
                });
            } catch (err) {
                errors.push(err);
            }
        }
        const err = new AggregateError(errors);
        err.message = `Issuer.discover() failed.${err.message.split('\n').filter((line)=>!line.startsWith('        at')).join('\n')}`;
        throw err;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.metadata, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = Issuer;
}}),
"[project]/node_modules/openid-client/lib/helpers/deep_clone.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = (obj)=>JSON.parse(JSON.stringify(obj));
}}),
"[project]/node_modules/openid-client/lib/passport_strategy.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-underscore-dangle */ const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const { format } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const cloneDeep = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/deep_clone.js [app-route] (ecmascript)");
const { RPError, OPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const { BaseClient } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/client.js [app-route] (ecmascript)");
const { random, codeChallenge } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/generators.js [app-route] (ecmascript)");
const pick = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/pick.js [app-route] (ecmascript)");
const { resolveResponseType, resolveRedirectUri } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/client.js [app-route] (ecmascript)");
function verified(err, user, info = {}) {
    if (err) {
        this.error(err);
    } else if (!user) {
        this.fail(info);
    } else {
        this.success(user, info);
    }
}
/**
 * @name constructor
 * @api public
 */ function OpenIDConnectStrategy({ client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {}, verify) {
    if (!(client instanceof BaseClient)) {
        throw new TypeError('client must be an instance of openid-client Client');
    }
    if (typeof verify !== 'function') {
        throw new TypeError('verify callback must be a function');
    }
    if (!client.issuer || !client.issuer.issuer) {
        throw new TypeError('client must have an issuer with an identifier');
    }
    this._client = client;
    this._issuer = client.issuer;
    this._verify = verify;
    this._passReqToCallback = passReqToCallback;
    this._usePKCE = usePKCE;
    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;
    this._params = cloneDeep(params);
    this._extras = cloneDeep(extras);
    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);
    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);
    if (!this._params.scope) this._params.scope = 'openid';
    if (this._usePKCE === true) {
        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;
        if (supportedMethods && supportedMethods.includes('S256')) {
            this._usePKCE = 'S256';
        } else if (supportedMethods && supportedMethods.includes('plain')) {
            this._usePKCE = 'plain';
        } else if (supportedMethods) {
            throw new TypeError('neither code_challenge_method supported by the client is supported by the issuer');
        } else {
            this._usePKCE = 'S256';
        }
    } else if (typeof this._usePKCE === 'string' && ![
        'plain',
        'S256'
    ].includes(this._usePKCE)) {
        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);
    }
    this.name = url.parse(client.issuer.issuer).hostname;
}
OpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {
    (async ()=>{
        const client = this._client;
        if (!req.session) {
            throw new TypeError('authentication requires session support');
        }
        const reqParams = client.callbackParams(req);
        const sessionKey = this._key;
        /* start authentication request */ if (Object.keys(reqParams).length === 0) {
            // provide options object with extra authentication parameters
            const params = {
                state: random(),
                ...this._params,
                ...options
            };
            if (!params.nonce && params.response_type.includes('id_token')) {
                params.nonce = random();
            }
            req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');
            if (this._usePKCE && params.response_type.includes('code')) {
                const verifier = random();
                req.session[sessionKey].code_verifier = verifier;
                switch(this._usePKCE){
                    case 'S256':
                        params.code_challenge = codeChallenge(verifier);
                        params.code_challenge_method = 'S256';
                        break;
                    case 'plain':
                        params.code_challenge = verifier;
                        break;
                }
            }
            this.redirect(client.authorizationUrl(params));
            return;
        }
        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];
        if (Object.keys(session || {}).length === 0) {
            throw new Error(format('did not find expected authorization request details in session, req.session["%s"] is %j', sessionKey, session));
        }
        const { state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType } = session;
        try {
            delete req.session[sessionKey];
        } catch (err) {}
        const opts = {
            redirect_uri: this._params.redirect_uri,
            ...options
        };
        const checks = {
            state,
            nonce,
            max_age: maxAge,
            code_verifier: codeVerifier,
            response_type: responseType
        };
        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);
        const passReq = this._passReqToCallback;
        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;
        const args = [
            tokenset,
            verified.bind(this)
        ];
        if (loadUserinfo) {
            if (!tokenset.access_token) {
                throw new RPError({
                    message: 'expected access_token to be returned when asking for userinfo in verify callback',
                    tokenset
                });
            }
            const userinfo = await client.userinfo(tokenset);
            args.splice(1, 0, userinfo);
        }
        if (passReq) {
            args.unshift(req);
        }
        this._verify(...args);
    /* end authentication response */ })().catch((error)=>{
        if (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid') || error instanceof RPError) {
            this.fail(error);
        } else {
            this.error(error);
        }
    });
};
module.exports = OpenIDConnectStrategy;
}}),
"[project]/node_modules/openid-client/lib/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const Issuer = __turbopack_context__.r("[project]/node_modules/openid-client/lib/issuer.js [app-route] (ecmascript)");
const { OPError, RPError } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/errors.js [app-route] (ecmascript)");
const Registry = __turbopack_context__.r("[project]/node_modules/openid-client/lib/issuer_registry.js [app-route] (ecmascript)");
const Strategy = __turbopack_context__.r("[project]/node_modules/openid-client/lib/passport_strategy.js [app-route] (ecmascript)");
const TokenSet = __turbopack_context__.r("[project]/node_modules/openid-client/lib/token_set.js [app-route] (ecmascript)");
const { CLOCK_TOLERANCE, HTTP_OPTIONS } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/consts.js [app-route] (ecmascript)");
const generators = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/generators.js [app-route] (ecmascript)");
const { setDefaults } = __turbopack_context__.r("[project]/node_modules/openid-client/lib/helpers/request.js [app-route] (ecmascript)");
module.exports = {
    Issuer,
    Registry,
    Strategy,
    TokenSet,
    errors: {
        OPError,
        RPError
    },
    custom: {
        setHttpOptionsDefaults: setDefaults,
        http_options: HTTP_OPTIONS,
        clock_tolerance: CLOCK_TOLERANCE
    },
    generators
};
}}),

};

//# sourceMappingURL=node_modules_openid-client_8678633a._.js.map